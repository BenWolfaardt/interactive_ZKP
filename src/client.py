import logging
import random
import sys

from collections import defaultdict

import grpc

from proto.zkp_auth_pb2 import (
    AuthenticationAnswerRequest,
    AuthenticationAnswerResponse,
    AuthenticationChallengeRequest,
    AuthenticationChallengeResponse,
    RegisterRequest,
)
from proto.zkp_auth_pb2_grpc import AuthStub

from src.settings import Settings, load_settings, log_level_mapping


class Client:
    def __init__(self) -> None:
        self.settings: Settings | None = None
        self._logger: logging.Logger | None = None

        self.q: int = 0
        self.g: int = 0
        self.h: int = 0
        self.bits: int = 0
        # self.q: int | None = None
        # self.g: int | None = None
        # self.h: int | None = None
        # self.bits: int | None = None
        self.default_values = True
        self.log_level: str = "info"

        self.user: str | None = None
        self.user_data: dict = defaultdict(set)

    def set_variables(self) -> None:
        self.settings = load_settings()

        if self.settings:
            self.q = self.settings.q
            self.g = self.settings.g
            self.h = self.settings.h
            self.bits = self.settings.bits
            self.default_values = self.settings.default_values
            self.log_level = self.settings.log_level

    @property
    def logger(self) -> logging.Logger:
        if self._logger is None:
            self._logger = logging.getLogger("Client")
            self._logger.setLevel(log_level_mapping[self.log_level])
        return self._logger

    # TODO: data validation with pydantic?
    def Register(self, stub: AuthStub) -> None:
        # self.user = input("Enter your username: ")

        # while True:
        #     try:
        #         x = int(input("Enter your secret password (an integer): "))
        #         break
        #     except ValueError:
        #         self.logger.error(f"{self.user} your password must be an integer.")

        self.user = "Bob"
        x = 3

        y1: int = pow(self.g, x, self.q)
        y2: int = pow(self.h, x, self.q)

        # TODO probably get rid of this try except
        try:
            request = RegisterRequest(
                user=self.user,
                y1=y1,
                y2=y2,
            )
        # TODO: if we know the limits on this error we can implement it at the stdin part
        except ValueError as e:
            self.logger.exception(f"ValueError: {e}")
            sys.exit()

        try:
            stub.Register(request)
            self.logger.info(f"{self.user}, you have succesfully registered")
        except grpc.RpcError as rpc_error:
            if rpc_error.code() == grpc.StatusCode.ALREADY_EXISTS:
                self.logger.error(f"{rpc_error.details()}")
            else:
                self.logger.exception(f"Caught a gRPC error: {rpc_error}")
            sys.exit()
        except Exception as e:
            self.logger.exception(f"Caught an exception: {e}")
            sys.exit()

        self.user_data[self.user] = {
            "user_name": self.user,
            "x": x,
        }

    def CreateAuthenticationChallenge(self, stub: AuthStub) -> AuthenticationChallengeResponse:
        if self.user:
            user: str = self.user

        # TODO ensure unique as repeated will result in leaking the x
        """
        Range Constraint: 'k' should be a random integer within the range [1, q - 1], where 'q' is the prime order of the groups generated by 'g' and 'h'. This range constraint ensures that 'k' is within the valid range of the protocol and not equal to 0 or greater than or equal to 'q'.

        Independence: 'k' should be independently and uniformly randomly chosen for each commitment. This means that each time the prover generates a commitment, it selects a new, unrelated value for 'k'. This independence prevents the verifier from deducing any information about 'k' or 'x' from multiple commitments.
        """
        # TODO: k needs to be unique, if it is the same, then they can determine our x
        k: int = random.randint(1, self.q - 1)
        r1: int = pow(self.g, k, self.q)
        r2: int = pow(self.h, k, self.q)

        request = AuthenticationChallengeRequest(
            user=user,
            r1=r1,
            r2=r2,
        )

        self.user_data[self.user]["k"] = k

        self.logger.debug(f"The authentication challenge variables for {user} are: {k=}, {r1=}, {r2=}")
        response: AuthenticationChallengeResponse = stub.CreateAuthenticationChallenge(request)
        return response

    def VerifyAuthentication(
        self, stub: AuthStub, authentication_challenge_response: AuthenticationChallengeResponse
    ) -> None:
        auth_id: str = authentication_challenge_response.auth_id
        c: int = authentication_challenge_response.c
        k: int = self.user_data[self.user]["k"]
        x: int = self.user_data[self.user]["x"]

        s = (k - c * x) % self.q

        request = AuthenticationAnswerRequest(
            auth_id=auth_id,
            s=s,
        )

        try:
            response: AuthenticationAnswerResponse = stub.VerifyAuthentication(request)
            session_id = response.session_id
            self.logger.info(f"{self.user}'s {session_id=}")
        except grpc.RpcError as rpc_error:
            if rpc_error.code() == grpc.StatusCode.UNAUTHENTICATED:
                self.logger.error(f"{rpc_error.details()}")
            else:
                self.logger.exception(f"Caught a gRPC error: {rpc_error}")
            sys.exit()
        except Exception as e:
            self.logger.exception(f"Caught an exception: {e}")
            sys.exit()

    def run(self) -> None:
        with grpc.insecure_channel("localhost:50051") as channel:
            stub: AuthStub = AuthStub(channel)
            self.Register(stub)
            authentication_challenge_response = self.CreateAuthenticationChallenge(stub)
            self.VerifyAuthentication(stub, authentication_challenge_response)


if __name__ == "__main__":
    logging.basicConfig()
    c = Client()
    c.set_variables()
    c.run()

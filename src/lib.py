import random


# Choose a random prime q (we use the Miller Rabin to generate this)

# Configure the Gennerator of the cyclic group
#   g is expressed as G subscript q

"""
g^x = y1 and h^x = y2: These equations describe the discrete logarithm problem, where you are trying to find the value of "x" given the generator "g" (or "h") and the resulting value "y1" (or "y2").

Modular Arithmetic: In most cryptographic settings, these exponentiation operations are done modulo a prime number "p." So, the equations become:

g^x ≡ y1 (mod p)
h^x ≡ y2 (mod p)
"""


""" What we need to know beforehand

Generators g and h: Both the prover and the verifier need to know the generators "g" and "h." These generators are used to form the groups over which the protocol operates. They should be publicly agreed-upon elements.

Prime order q: It is important that the prover and verifier know the prime order "q" of the groups generated by "g" and "h." The order of the group represents the number of elements in the group.

Public values y1 and y2: These values are computed by raising the generators "g" and "h" to the common discrete logarithm "x." The prover and verifier both need to know these public values, which are typically shared as part of the protocol.

Security parameter choices: Parameters related to the security of the protocol, such as the number of bits in the prime "q" and the security settings for the protocol, should be publicly known and agreed upon by both parties.

Challenge and response format: The prover and verifier need to know how challenges and responses are formatted in the protocol, including the range or format of challenges, how they are generated, and how responses are computed and transmitted.
"""


class PrimeGenerator:
    def is_prime(self, n: int, k: int = 5) -> bool:
        if n <= 1:
            return False
        if n <= 3:
            return True

        # Write n as 2^r * d + 1
        r, d = 0, n - 1
        while d % 2 == 0:
            r += 1
            d //= 2

        # Miller-Rabin primality test
        for _ in range(k):
            a = random.randint(2, n - 2)
            x = pow(a, d, n)
            if x == 1 or x == n - 1:
                continue

            for _ in range(r - 1):
                x = pow(x, 2, n)
                if x == n - 1:
                    break
            else:
                return False

        return True

    def find_prime(self, bits: int) -> int:
        while True:
            candidate = random.getrandbits(bits)
            if candidate % 2 == 0:
                candidate += 1
            if self.is_prime(candidate):
                return candidate


class ChaumPedersenProtocol:
    def __init__(self, g: int, h: int, p: int, x: int) -> None:
        self.g = g
        self.h = h
        self.p = p
        self.x = x

    def compute_y_values(self) -> tuple[int, int]:
        y1 = pow(self.g, self.x, self.p)
        y2 = pow(self.h, self.x, self.p)
        return y1, y2


if __name__ == "__main__":
    tg = PrimeGenerator()
    prime = tg.find_prime(256)
    print(prime)

    # generate_initalisation_variables = PrimeGenerator()
    # g = generate_initalisation_variables.g
    # h = generate_initalisation_variables.h
    # p = generate_initalisation_variables.p
    # print(f"{g=}, {h=}, {p=}")

    # x = 123456

    # protocol = ChaumPedersenProtocol(g, h, p, x)
    # y1, y2 = protocol.compute_y_values()

import math
import random


# Choose a random prime q (we use the Miller Rabin to generate this)

# Configure the Gennerator of the cyclic group
#   g is expressed as G subscript q

"""
g^x = y1 and h^x = y2: These equations describe the discrete logarithm problem, where you are trying to find the value of "x" given the generator "g" (or "h") and the resulting value "y1" (or "y2").

Modular Arithmetic: In most cryptographic settings, these exponentiation operations are done modulo a prime number "p." So, the equations become:

g^x ≡ y1 (mod p)
h^x ≡ y2 (mod p)
"""


""" What we need to know beforehand

Generators g and h: Both the prover and the verifier need to know the generators "g" and "h." These generators are used to form the groups over which the protocol operates. They should be publicly agreed-upon elements.

Prime order q: It is important that the prover and verifier know the prime order "q" of the groups generated by "g" and "h." The order of the group represents the number of elements in the group.

Public values y1 and y2: These values are computed by raising the generators "g" and "h" to the common discrete logarithm "x." The prover and verifier both need to know these public values, which are typically shared as part of the protocol.

Security parameter choices: Parameters related to the security of the protocol, such as the number of bits in the prime "q" and the security settings for the protocol, should be publicly known and agreed upon by both parties.

Challenge and response format: The prover and verifier need to know how challenges and responses are formatted in the protocol, including the range or format of challenges, how they are generated, and how responses are computed and transmitted.
"""

bits: int = 32


class PublicVariableGenerator:
    # k selected as per page 188
    # TODO go through the algorithm and compare to book
    def _is_prime(self, n: int, k: int = 20) -> bool:
        if n <= 1:
            return False
        if n <= 3:
            return True

        # Write n as 2^r * d + 1
        r, d = 0, n - 1
        while d % 2 == 0:
            r += 1
            d //= 2

        # TODO see:
        #   - https://web.archive.org/web/20130328080230/http://en.literateprograms.org/Miller-Rabin_primality_test_%28Python%29
        #   - https://stackoverflow.com/questions/15347174/python-finding-prime-factors
        # Miller-Rabin primality test
        #   used to test if something is prime with high confidence
        #   pg. 188 in Cryptography: An Introduction
        for _ in range(k):
            a = random.randint(2, n - 2)
            x = pow(a, d, n)
            if x == 1 or x == n - 1:
                continue

            for _ in range(r - 1):
                x = pow(x, 2, n)
                if x == n - 1:
                    break
            else:
                return False

        return True

    def _get_prime(self, bits: int) -> int:
        while True:
            candidate = random.getrandbits(bits)
            if candidate % 2 == 0:
                candidate += 1
            if self._is_prime(candidate):
                return candidate

    # This approach was formulated primarily on Cryptography: An Introduction (3rd Edition) by Nigel Smart.
    class Approach1:
        def __init__(self, PublicVariableGenerator: "PublicVariableGenerator") -> None:
            self.q: int = PublicVariableGenerator._get_prime(bits)

        # Euler's totient
        #   also known as Euler's totient
        #   used to test for primitive roots
        #   pg. 5 in Cryptography: An Introduction
        def _eulers_phi_function(self, n: int) -> int:
            result = n
            for p in range(2, int(math.sqrt(n)) + 1):
                if n % p == 0:
                    while n % p == 0:
                        n //= p
                    result -= result // n
            if n > 1:
                result -= result // n
            return result

        def _find_coprime(self, n: int) -> int:
            while True:
                candidate = random.randint(2, n - 1)
                if math.gcd(candidate, n) == 1:
                    return candidate

        def get_public_variables(self) -> tuple[int, int, int]:
            q = self.q
            g = self._find_coprime(q)
            while True:
                h = self._find_coprime(q)
                if h != g:
                    break

            return q, g, h

    # Whilst grappling with this challenge I came across another approach which I my curiosity wanted to investigate.
    class Approach2:
        def __init__(self, PublicVariableGenerator: "PublicVariableGenerator") -> None:
            # TODO set bits in yaml
            self.p: int = PublicVariableGenerator._get_prime(bits)
            self.q: int = 2 * self.p + 1  # But needs to also be a prime

            # This is the a, b, ab approach

        # def get_public_variables(self) -> tuple[int, int, int]:
        #     pass
        #     q = self.q
        #     g = self.g
        #     h = self.h

        #     return q, g, h


if __name__ == "__main__":
    generator = PublicVariableGenerator()

    approach_1 = generator.Approach1(generator)
    q, g, h = approach_1.get_public_variables()
    print(f"Approach 1: {q=}, {g=}, {h=}\n")

    approach_2 = generator.Approach2(generator)
    # q, g, h = approach_2.get_public_variables()
    # print(f"Approach 2: {q=}, {g=}, {h=}")

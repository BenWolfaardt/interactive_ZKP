import logging
import random
import uuid

from collections import defaultdict
from concurrent import futures

import grpc
import proto.zkp_auth_pb2_grpc as zkp_auth_pb2_grpc

from grpc import ServicerContext
from proto.zkp_auth_pb2 import (
    AuthenticationAnswerRequest,
    AuthenticationAnswerResponse,
    AuthenticationChallengeRequest,
    AuthenticationChallengeResponse,
    RegisterRequest,
    RegisterResponse,
)


# TODO: get fom yaml config
q: int = 50587  # The random challenge variable generated by the verifier in the Chaum–Pedersen protocol is typically an integer within the bounds of [1, q - 1], where 'q' is the prime order of the groups generated by 'g' and 'h'.
g: int = 2
h: int = 3


class AuthServicer(zkp_auth_pb2_grpc.AuthServicer):
    def __init__(self) -> None:
        super().__init__()
        self.user: str | None = None
        self.user_data: dict = defaultdict(set)

    def Register(self, request: RegisterRequest, context: ServicerContext) -> RegisterResponse:
        self.user = request.user
        y1: int = request.y1
        y2: int = request.y2

        if self.user in self.user_data:
            e = f"User '{self.user}' already exists"
            logging.error(e)
            context.set_code(grpc.StatusCode.ALREADY_EXISTS)
            context.set_details(e)
        else:
            self.user_data[self.user] = {
                "user_name": self.user,
                "y1": y1,
                "y2": y2,
            }
            logging.debug(f"{self.user} has registered with {y1=} and {y2=}")

        return RegisterResponse()

    def CreateAuthenticationChallenge(
        self, request: AuthenticationChallengeRequest, context: ServicerContext
    ) -> AuthenticationChallengeResponse:
        auth_id: uuid.UUID = uuid.uuid4()
        user: str = request.user
        r1: int = request.r1
        r2: int = request.r2

        """
        Authentication protocols usually employ a cryptographic nonce as the challenge to ensure that every
        challenge–response sequence is unique. This protects against Eavesdropping with a subsequent replay attack.
        If it is impractical to implement a true nonce, a strong cryptographically secure pseudorandom number generator
        and cryptographic hash function can generate challenges that are highly unlikely to occur more than once.
        It is sometimes important not to use time-based nonces, as these can weaken servers in different time zones
        and servers with inaccurate clocks.
        """

        # concatenated_values = str(r1) + str(r2) + str(y1) + str(y2)
        # print(concatenated_values)
        # hash_value = hashlib.sha256(concatenated_values.encode()).hexdigest()
        # print(hash_value)
        # challenge = int(hash_value, 16)
        # print(challenge)
        # # c = challenge % q

        c: int = random.randint(1, q - 1)

        self.user_data[user]["c"] = c
        self.user_data[user]["r1"] = r1
        self.user_data[user]["r2"] = r2
        logging.debug(f"{user} has parsed {r1=} and {r2=}")

        return AuthenticationChallengeResponse(
            auth_id=str(auth_id),
            c=c,
        )

    def VerifyAuthentication(
        self, request: AuthenticationAnswerRequest, context: ServicerContext
    ) -> AuthenticationAnswerResponse:
        # TODO create pydantic model so that we can access things more easily
        s: int = request.s
        c: int = self.user_data[self.user]["c"]
        y1: int = self.user_data[self.user]["y1"]
        y2: int = self.user_data[self.user]["y2"]
        r1_original: int = self.user_data[self.user]["r1"]
        r2_original: int = self.user_data[self.user]["r2"]

        r1_new = (pow(g, s, q) * pow(y1, c, q)) % q
        r2_new = (pow(h, s, q) * pow(y2, c, q)) % q

        # TODO: add am expiration
        # TODO: reset the auth_id as it's been used
        if r1_new == r1_original and r2_new == r2_original:
            logging.info(f"{self.user} has successfully been authenticated")
            return AuthenticationAnswerResponse(
                session_id="Eureka, you cracked the coding challenge",
            )
        else:
            e = f"The ZKP authentication was Unsuccessful for '{self.user}'."
            logging.error(e)
            context.set_code(grpc.StatusCode.UNAUTHENTICATED)
            context.set_details(e)
            return AuthenticationAnswerResponse()


def serve() -> None:
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    zkp_auth_pb2_grpc.add_AuthServicer_to_server(AuthServicer(), server)
    server.add_insecure_port("[::]:50051")
    server.start()
    server.wait_for_termination()


if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG)
    serve()

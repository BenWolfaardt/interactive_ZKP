# Notes

## Links

- Chaum-Pedersen Protocol
    - https://crypto.stackexchange.com/questions/99262/chaum-pedersen-protocol
- Finding a coprime of a general magnitude.
    - https://math.stackexchange.com/questions/2430742/finding-a-coprime-of-a-general-magnitude
- Finding a primitive root of a prime number
    - https://math.stackexchange.com/questions/124408/finding-a-primitive-root-of-a-prime-number
- Greatest Common Divisor of prime numbers
    - https://math.stackexchange.com/questions/2433888/greatest-common-divisor-of-prime-numbers
- Smallest prime divisor of a number
    - https://www.geeksforgeeks.org/smallest-prime-divisor-of-a-number/
- Miller-Rabin primality test (Python)
    - https://web.archive.org/web/20130328080230/http://en.literateprograms.org/Miller-Rabin_primality_test_%28Python%29
- Python Finding Prime Factors
    - https://stackoverflow.com/questions/15347174/python-finding-prime-factors
- GitHub repos (there are others, but these were the best I found for Python)
    - Go - https://github.com/srinathln7/zkp-authentication/tree/main
    - Jupyter - https://github.com/ncatanoc/chaum_pedersen/blob/main/ZKP_protocol.ipynb
    - Python
        - https://github.com/AvishayYanay/ChaumPedersenZKP/tree/main
            - Great maths and using 1024 bits for prime generation
    - Python & Rust - https://github.com/jcabrero/chaum-pedersen-zkp/tree/main

## ChatGPT notes

- I'd still like to implement two options:


You're correct to be cautious; the code snippet as given does not ensure that p is a safe prime. A safe prime is a prime number of the form p = 2q + 1, where q is also a prime number. These primes are called "safe" because the multiplicative group modulo p has a subgroup of prime order q, which has desirable cryptographic properties, such as making the discrete logarithm problem hard.

In this subgroup, every element except the identity (which is 1 modulo p) has order q. To find g and h that generate the entire subgroup, you can pick elements at random and raise them to the power of (p-1)/q (which should be 2 if p is a safe prime and q is the Sophie Germain prime associated with it), and check if you get an element different from 1. This is because for any element a in the group, a^q mod p will be 1 if a is in the subgroup of order q, and any element to the power of the size of the group (p-1) will be 1 by Fermat's Little Theorem.

The code you have for generating \( g \) and \( h \) does not appear to correctly ensure that they are generators of the subgroup of prime order \( q \) within the group modulo \( p \). To be generators of this subgroup, \( g \) and \( h \) must satisfy the property that when raised to the power of \( q \), the result is 1 modulo \( p \), but not for any smaller exponent that divides \( q \) (since \( q \) is prime, the only smaller exponent to check is 1). However, your `_find_coprime` function only ensures that \( g \) and \( h \) are coprime to \( q \), which is a different property and doesn't guarantee that they are generators.

With these modifications, the `_find_generator` method will find a proper generator \( g \) of the subgroup of order \( q \) by testing that \( g^2 \mod p \neq 1 \) (ensuring it's not the identity element or its square) and that \( g^q \mod p = 1 \) (which must hold for any element of the subgroup).

You also asked whether you should use \( q \) or \( p \) in your ZKP protocol for modulus operations. Typically, in a subgroup of a prime-order \( q \) under modulo \( p \), operations are performed modulo \( p \), but the order of the subgroup (which is the maximum number of distinct elements you can have) is \( q \). So you would use \( p \) for modular arithmetic, but \( q \) would define the structure of the subgroup, such as when generating elements or when working within the protocol where the properties of the subgroup are used.

The ZKP protocol must be consistent with the group and subgroup it is intended to work with. So if your ZKP protocol is designed for a subgroup of order \( q \), then you would use \( q \) when the protocol requires operations that specifically rely on the structure of this subgroup (e.g., when you want to ensure that you're working with elements strictly within the subgroup). However, when you are doing general modular arithmetic, you would use \( p \). Make sure to follow the specific protocol requirements regarding which modulus to use for each operation.


The random challenge variable generated by the verifier in the Chaum–Pedersen protocol is typically an integer within the bounds of [1, q - 1], where 'q' is the prime order of the groups generated by 'g' and 'h'.

        """
        Authentication protocols usually employ a cryptographic nonce as the challenge to ensure that every
        challenge–response sequence is unique. This protects against Eavesdropping with a subsequent replay attack.
        If it is impractical to implement a true nonce, a strong cryptographically secure pseudorandom number generator
        and cryptographic hash function can generate challenges that are highly unlikely to occur more than once.
        It is sometimes important not to use time-based nonces, as these can weaken servers in different time zones
        and servers with inaccurate clocks.
        """



        from src.lib import PublicVariableGenerator
        ModuleNotFoundError: No module named 'src'
        (interview-nillion-py3.11) ➜  interview_nillion git:(main) ✗ export PYTHONPATH='src':$PYTHONPATH


        # Choose a random prime q (we use the Miller Rabin to generate this)

        # Configure the Gennerator of the cyclic group
        #   g is expressed as G subscript q

        """
        g^x = y1 and h^x = y2: These equations describe the discrete logarithm problem, where you are trying to find the value of "x" given the generator "g" (or "h") and the resulting value "y1" (or "y2").

        Modular Arithmetic: In most cryptographic settings, these exponentiation operations are done modulo a prime number "p." So, the equations become:

        g^x ≡ y1 (mod p)
        h^x ≡ y2 (mod p)
        """


        """ What we need to know beforehand

        Generators g and h: Both the prover and the verifier need to know the generators "g" and "h." These generators are used to form the groups over which the protocol operates. They should be publicly agreed-upon elements.

        Prime order q: It is important that the prover and verifier know the prime order "q" of the groups generated by "g" and "h." The order of the group represents the number of elements in the group.

        Public values y1 and y2: These values are computed by raising the generators "g" and "h" to the common discrete logarithm "x." The prover and verifier both need to know these public values, which are typically shared as part of the protocol.

        Security parameter choices: Parameters related to the security of the protocol, such as the number of bits in the prime "q" and the security settings for the protocol, should be publicly known and agreed upon by both parties.

        Challenge and response format: The prover and verifier need to know how challenges and responses are formatted in the protocol, including the range or format of challenges, how they are generated, and how responses are computed and transmitted.
        """



- [ ] async - https://github.com/grpc/grpc/blob/v1.58.0/examples/python/route_guide/asyncio_route_guide_client.py
- [ ] 0Explain config: flavour is either `exponentiations` or `eliptic_curve`
- [ ] Update mypy exclude; Manually eclude from mypy; Note this will be overwritten in the case that this file is re-generated
- [ ] LaTeX Output: sympy can generate LaTeX code for expressions, making it useful for creating mathematical documents.
